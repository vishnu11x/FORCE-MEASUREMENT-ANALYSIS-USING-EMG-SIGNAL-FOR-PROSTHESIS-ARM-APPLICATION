/*
 * adc.c
 *
 *  Created on: Sep 21, 2024
 *      Author: Vishnu
 */

#include <adc.h>

volatile uint32_t dma2_status;
volatile uint32_t adc_data[3];


void adc_init(void){

	// Enable clock
	RCC -> AHB1ENR |= (1U << 0);  //Clock For GPIOA
	RCC -> AHB1ENR |= (1U << 22);  //Clock for DMA2
	RCC -> APB2ENR |= (1U << 8);  //Clock for ADC1
	RCC -> APB2ENR |= (1U << 9);  //Clock for ADC2
	RCC -> APB2ENR |= (1U << 10);  //Clock for ADC3

	//Config GPIO
	GPIOA -> MODER |= (1U << 2) | (1U <<3); //Analog mode PA1
	GPIOA -> MODER |= (1U << 4) | (1U <<5);  //Analog mode PA2
	GPIOA -> MODER |= (1U << 6) | (1U << 7);  //Analog mode PA3

	//Triple Mode ADC1, ADC2, ADC3
	ADC -> CCR &= ~( (1U << 0) | (1U << 3) );
	ADC -> CCR |= (1U << 1) | (1U << 2) | (1U << 4);

	ADC -> CCR |= (1U << 14);  // Enable DMA mode 1
	ADC -> CCR &= ~(1U << 15);

	ADC -> CCR |= (1U << 13);  //Enable DMA Selection

//	ADC -> CCR &= ~(1U << 17);  // ADC Prescaler
//	ADC -> CCR |= (1U << 16);

	//ADC1 Config

	//Select channel
	ADC1 -> SQR3 &= ~( (1U << 1) | (1U << 2) | (1U << 3) | (1U << 4));
	ADC1 -> SQR3 |= (1U << 0);

	ADC1 -> CR2 |= (1U << 28);  //Enable External trigger
	ADC1 -> CR2 &= ~(1U << 29);

	ADC1 -> CR2 |= ( 1U << 28 ); //  Enable external trigger on rising edge for ADC1
	ADC1 -> CR2 |= ( 1U << 29 );

	ADC1 -> CR2 &= ~(1U << 24); // Select TIM2 TRGO event for external trigger
	ADC1 -> CR2 |= (1U << 25);
	ADC1 -> CR2 |= (1U << 26);
	ADC1 -> CR2 &= ~(1U << 27);
	ADC1 -> CR2 |= (1U << 0);

	//ADC2 Config
	//Select channel
	ADC2 -> CR2 |= (1U << 1);
	ADC2 -> SQR3 &= ~( (1U << 0) | (1U << 2) | (1U << 3) | (1U << 4));
	ADC2 -> SQR3 |= (1U << 1);
	ADC2 -> CR2 |= (1U << 0);


	//ADC3 Config
	ADC3 -> CR2 |= (1U << 1);
	ADC3 -> SQR3 &= ~( (1U << 2) | (1U << 3) | (1U << 4));
	ADC3 -> SQR3 |= (1U << 0) | (1U << 1);
	ADC3 -> CR2 |= (1U << 0);


	/* CONFIG DMA */
		RCC -> AHB1ENR |= (1U << 22);  // Enable clock for DMA
		DMA2_Stream0 -> CR &= ~(1U << 0) ;  // Disable DMA stream

		while(( (DMA2_Stream0 -> CR) & (1U  << 0) )){}  // Wait till stream is disable
		DMA2_Stream0 -> CR |= (1U << 8);  // Enable circular mode

		DMA2_Stream0 -> CR |= (1U << 13); // Set Msize to 16-bit (half-word)
		DMA2_Stream0 -> CR &= ~(1U << 14);

		DMA2_Stream0 -> CR |= (1U << 11);  // Set Psize to 16-bit (half-word)
		DMA2_Stream0 -> CR &= ~(1U << 12);

		DMA2_Stream0 -> CR |= (1U << 10);  // Enable memory increment

		DMA2_Stream0 -> PAR = (uint32_t)(&(ADC -> CDR));  // Set periph address
		DMA2_Stream0 -> M0AR = (uint32_t)(&adc_data);  // Set memory address

		DMA2_Stream0 -> NDTR = 3;  // Set No.of data item to transfer

		DMA2_Stream0 -> CR |= (1U << 4);  // Enable Transfer complete interrupt
		NVIC_EnableIRQ(DMA2_Stream0_IRQn);  // Enable DMA interruot in NVIC




		/* CONFIG TIMER FOR TRIGGER (2000HZ) */
		RCC -> APB1ENR |= ( 1U << 0); // Enable clock for TIM2
		TIM2 -> PSC = (8400 - 1);  // Set prescaler for 10000Hz timer frequency
		TIM2 -> ARR = (1000-1);  // Set auto reload value

		TIM2 -> CR2 &= ~(( 1U << 4) | ( 1U << 6));  // Select update event for TRGO
		TIM2 -> CR2 |= ( 1U << 5);

}

void adc_start(void){
	DMA2_Stream0 -> CR |= (1U << 0);  // Enable DMA stream
	ADC1 -> CR2 |= (1U << 30);
	ADC2 -> CR2 |= (1U << 30);
	ADC3 -> CR2 |= (1U << 30);

	TIM2 -> CR1 |= ( 1U << 0);  // Enable TIM2

}





void DMA2_Stream0_IRQHandler(void){

	if((DMA2 -> LISR) & (1U << 5)){

		dma2_status = 1;

		DMA2 -> LIFCR |= (1U << 5);

	}

}





